// Global error handler to prevent crashes
window.addEventListener('error', (event) => {
  console.error('Global error caught:', event.error);
  toast('An error occurred: ' + event.error.message);
  event.preventDefault(); // Prevent default error handling
});

window.addEventListener('unhandledrejection', (event) => {
  console.error('Unhandled promise rejection:', event.reason);
  toast('An error occurred: ' + event.reason);
  event.preventDefault(); // Prevent default error handling
});

// Enhanced error handling and logging
console.log('=== Trading Journal App Starting ===');

const PREDEFINED_INSTRUMENTS = {
  'GOLD': {
    symbol: 'GOLD',
    displayName: 'Gold (XAU/USD)',
    tick_size: 0.01,
    tick_value: 0.01,
    contract_size: 100,
    category: 'Commodities'
  },
  'MINI_NASDAQ': {
    symbol: 'MINI_NASDAQ',
    displayName: 'Mini Nasdaq (MNQ)',
    tick_size: 0.25,
    tick_value: 1.25,
    contract_size: 1,
    category: 'Indices'
  },
  'MICRO_NASDAQ': {
    symbol: 'MICRO_NASDAQ',
    displayName: 'Micro Nasdaq (NQ)',
    tick_size: 0.25,
    tick_value: 0.25,
    contract_size: 1,
    category: 'Indices'
  },
  'NASDAQ_100': {
    symbol: 'NASDAQ_100',
    displayName: 'Nasdaq 100 (NDX)',
    tick_size: 0.25,
    tick_value: 25.00,
    contract_size: 1,
    category: 'Indices'
  }
};

const state = {
  baseUrl: '',
  settings: null,
  instruments: [],
  balance_current: 0,
  trades: [],
};

const routes = {
  '#dashboard': renderDashboard,
  '#new': renderNewTrade,
  '#trades': renderTrades,
  '#settings': renderSettings,
};

console.log('Setting up event listeners...');

// Setup event listeners
window.addEventListener('load', () => {
  console.log('Window loaded, initializing app...');
  init().catch(err => {
    console.error('Init failed:', err);
    toast('Failed to initialize app: ' + err.message);
  });
});

window.addEventListener('hashchange', () => {
  console.log('Hash changed to:', window.location.hash);
  navigate();
});

// Enhanced navigation click handler
document.addEventListener('click', (e) => {
  console.log('Click detected on:', e.target);
  if (e.target.classList.contains('nav-link')) {
    e.preventDefault();
    const route = e.target.dataset.route;
    console.log('Navigation button clicked:', route);
    if (route) {
      window.location.hash = route;
    } else {
      console.error('No route found on clicked element');
    }
  }
});

async function init(){
  try {
    console.log('Initializing app...');

    // Check if templates are loaded
    const templates = ['tpl-dashboard', 'tpl-new', 'tpl-trades', 'tpl-settings'];
    const missingTemplates = templates.filter(id => !document.getElementById(id));
    if (missingTemplates.length > 0) {
      console.error('Missing templates:', missingTemplates);
      toast('Error: Missing templates - ' + missingTemplates.join(', '));
      return;
    }
    console.log('All templates found');

    state.baseUrl = window.WEB_APP_URL || '';
    console.log('Base URL:', state.baseUrl);

    await refreshSettings();

    // Ensure we have a hash before navigating
    if (!window.location.hash) {
      window.location.hash = '#dashboard';
    }

    navigate();
    console.log('App initialized successfully');
  } catch (error) {
    console.error('Init error:', error);
    // Fallback to basic functionality
    state.settings = {
      starting_balance: 10000,
      daily_target: 100,
      daily_max_loss: 50,
      tp_pct: 0.02,
      sl_pct: 0.01
    };
    state.instruments = Object.values(PREDEFINED_INSTRUMENTS);
    state.balance_current = 10000;

    // Ensure we have a hash before navigating
    if (!window.location.hash) {
      window.location.hash = '#dashboard';
    }

    navigate();
    toast('Using fallback settings - check console for details');
  }
}

function navigate(){
  try {
    const hash = window.location.hash || '#dashboard';
    console.log('Navigating to:', hash);

    // Hide all views
    document.querySelectorAll('.view').forEach(v => v.classList.add('hidden'));

    // Remove active class from all nav links
    document.querySelectorAll('.nav-link').forEach(link => link.classList.remove('active'));

    // Add active class to current nav link
    const activeLink = document.querySelector(`[data-route="${hash}"]`);
    if (activeLink) {
      activeLink.classList.add('active');
      console.log('Active link found and activated');
    } else {
      console.log('Active link not found for route:', hash);
    }

    // Render the appropriate view
    const fn = routes[hash] || renderDashboard;
    if (typeof fn === 'function') {
      console.log('Calling render function for:', hash);
      fn();
    } else {
      console.error('Route function not found for:', hash);
      renderDashboard();
    }
  } catch (error) {
    console.error('Navigation error:', error);
    toast('Navigation error: ' + error.message);
  }
}

async function refreshSettings(){
  try {
    console.log('Refreshing settings...');
    const res = await apiGet('/api/settings');

    if (res && res.ok) {
      state.settings = res.settings;
      state.instruments = res.instruments || [];
      state.balance_current = res.balance_current || 0;

      // If no instruments are configured, use predefined ones
      if (!state.instruments || state.instruments.length === 0) {
        console.log('No instruments configured, using predefined ones');
        state.instruments = Object.values(PREDEFINED_INSTRUMENTS);
      }

      console.log('Settings loaded successfully:', {
        settings: state.settings,
        instrumentsCount: state.instruments.length,
        balance: state.balance_current
      });
    } else {
      throw new Error(res?.error || 'Failed to load settings');
    }
  } catch (error) {
    console.error('Settings refresh failed:', error);

    // Use default settings and predefined instruments
    state.settings = {
      starting_balance: 10000,
      daily_target: 515,
      daily_max_loss: 1500,
      tp_pct: 0.30,
      sl_pct: 0.15
    };
    state.instruments = Object.values(PREDEFINED_INSTRUMENTS);
    state.balance_current = 10000;

    console.log('Using fallback settings');
    toast('Using default settings - API may not be working');
  }
}

function fmt(n){ if(n===undefined||n===null||n==='') return '—'; return '$' + Number(n).toLocaleString('en-US', { maximumFractionDigits: 2 }); }
function pct(n){ if(n===undefined||n===null||n==='') return '—'; return (Number(n)*100).toFixed(0)+'%'; }

function renderDashboard(){
  console.log('Rendering dashboard...');
  const container = document.getElementById('view-dashboard');
  if (!container) {
    console.error('Dashboard container not found!');
    return;
  }

  const template = document.getElementById('tpl-dashboard');
  if (!template) {
    console.error('Dashboard template not found!');
    return;
  }

  container.innerHTML = template.innerHTML;
  container.classList.remove('hidden');
  console.log('Dashboard rendered successfully');

  const s = state.settings || {};
  document.getElementById('cur-balance').textContent = fmt(state.balance_current);
  document.getElementById('daily-target').textContent = fmt(s.daily_target);
  document.getElementById('daily-max-loss').textContent = fmt(s.daily_max_loss);

  const today = new Date();
  const sd = today.toISOString().slice(0,10);
  apiGet('/api/trades?start_date='+sd+'&end_date='+sd).then(res => {
    const trades = (res.trades||[]);
    let sum = 0, wins=0, los=0; let rrSum=0, rrCnt=0;
    trades.forEach(t => {
      if (typeof t.pnl === 'number') sum += t.pnl;
      if (typeof t.rr === 'number') { rrSum += t.rr; rrCnt++; }
      if (t.status === 'TP' || (t.pnl>0)) wins++;
      if (t.status === 'SL' || (t.pnl<0)) los++;
    });
    const target = Number(s.daily_target || 0);
    const prog = target? Math.max(0, Math.min(100, (sum/target)*100)):0;
    document.getElementById('today-pnl').textContent = fmt(sum);
    document.getElementById('today-target').textContent = fmt(target);
    document.getElementById('progress-fill').style.width = prog + '%';
    document.getElementById('hit-rate-day').textContent = ((wins+los)>0? Math.round((wins/(wins+los))*100):0) + '%';
    document.getElementById('avg-rr').textContent = rrCnt? fmt(rrSum/rrCnt) : '—';
    document.getElementById('sum-day').textContent = fmt(sum);
  });

  const now = new Date();
  const day = (now.getDay()+6)%7;
  const monday = new Date(now); monday.setDate(now.getDate()-day);
  const sunday = new Date(monday); sunday.setDate(monday.getDate()+6);
  const sd2 = monday.toISOString().slice(0,10);
  const ed2 = sunday.toISOString().slice(0,10);
  apiGet('/api/trades?start_date='+sd2+'&end_date='+ed2).then(res => {
    const trades = (res.trades||[]);
    let sum = 0, wins=0, los=0;
    trades.forEach(t => {
      if (typeof t.pnl === 'number') sum += t.pnl;
      if (t.status === 'TP' || (t.pnl>0)) wins++;
      if (t.status === 'SL' || (t.pnl<0)) los++;
    });
    document.getElementById('sum-week').textContent = fmt(sum);
    document.getElementById('hit-rate-week').textContent = ((wins+los)>0? Math.round((wins/(wins+los))*100):0) + '%';
  });
}

function renderNewTrade(){
  console.log('Rendering new trade form...');
  const container = document.getElementById('view-new');
  if (!container) {
    console.error('New trade container not found!');
    return;
  }

  const template = document.getElementById('tpl-new');
  if (!template) {
    console.error('New trade template not found!');
    return;
  }

  container.innerHTML = template.innerHTML;
  container.classList.remove('hidden');
  console.log('New trade template rendered');

  const form = container.querySelector('#new-trade-form');
  const symbolSel = container.querySelector('#symbol-select');
  const autoTP = container.querySelector('#auto-tp');

  if (!form || !symbolSel) {
    console.error('Form or symbol select not found!');
    return;
  }

  const s = state.settings || {};
  container.querySelector('#si-balance').textContent = fmt(state.balance_current);
  container.querySelector('#si-tp').textContent = pct(Number(s.tp_pct || 0.3));
  container.querySelector('#si-sl').textContent = pct(Number(s.sl_pct || 0.15));

  const now = new Date();
  form.date.value = now.toISOString().slice(0,10);
  form.time.value = now.toTimeString().slice(0,5);

  // Ensure we have instruments loaded
  let instruments = state.instruments || [];
  if (!instruments || instruments.length === 0) {
    console.log('No instruments found, using predefined ones');
    instruments = Object.values(PREDEFINED_INSTRUMENTS);
    state.instruments = instruments;
  }

  console.log('Loading instruments for symbol select:', instruments);

  symbolSel.innerHTML = '<option value="">Select Symbol</option>' +
    instruments.map(i => `<option value="${i.symbol}">${i.displayName || i.symbol}</option>`).join('');

  const draft = JSON.parse(localStorage.getItem('new-trade-draft')||'{}');
  Object.keys(draft).forEach(k => {
    if (form[k] !== undefined) form[k].value = draft[k];
  });

  form.addEventListener('input', () => {
    const data = Object.fromEntries(new FormData(form).entries());
    localStorage.setItem('new-trade-draft', JSON.stringify(data));
    updateSideInfo();
  });

  async function updateSideInfo(){
    const entry = Number(form.entry.value);
    const stop = Number(form.stop.value);
    const direction = form.direction.value;
    const symbol = form.symbol.value;
    const instrument = instruments.find(x=>x.symbol===symbol);
    const tp_pct = Number(s.tp_pct || 0.3);
    const sl_pct = Number(s.sl_pct || 0.15);
    const plan = computePlanClient({ balance: state.balance_current, tp_pct, sl_pct, entry, stop, direction, instrument });
    container.querySelector('#si-risk').textContent = fmt(plan.risk_amount);
    container.querySelector('#si-tp-amount').textContent = fmt(plan.planned_tp_amount);
    container.querySelector('#si-sl-amount').textContent = fmt(plan.planned_sl_amount);
    container.querySelector('#si-rr').textContent = fmt(plan.rr);
    if (!form.qty.value && plan.qty) form.qty.value = plan.qty;
    if (autoTP.checked && plan.take_profit && !form.take_profit.value) form.take_profit.value = plan.take_profit;
  }
  updateSideInfo();

  form.addEventListener('submit', async (ev) => {
    ev.preventDefault();
    console.log('New trade form submitted');

    const status = ev.submitter && ev.submitter.dataset.status || 'Planned';
    const data = Object.fromEntries(new FormData(form).entries());

    console.log('Form data:', data);

    if (!data.symbol) return toast('Please select a symbol');
    if (!data.direction) return toast('Please select direction');
    if (data.entry && data.stop && Number(data.entry) === Number(data.stop)) return toast('Entry and Stop cannot be the same');

    const payload = {
      date: data.date,
      time: data.time,
      symbol: data.symbol,
      direction: data.direction,
      entry: numOrNull(data.entry),
      stop: numOrNull(data.stop),
      take_profit: numOrNull(data.take_profit),
      qty: numOrNull(data.qty),
      status,
      commission: numOrNull(data.commission) || 0,
      fees: numOrNull(data.fees) || 0,
      auto_take_profit: autoTP.checked
    };

    console.log('Sending trade payload:', payload);

    try {
      const res = await apiPost('/api/trades', payload);
      console.log('Trade save response:', res);

      if (res.ok) {
        toast('Trade saved successfully');
        localStorage.removeItem('new-trade-draft');
        window.location.hash = '#trades';
      } else {
        throw new Error(res.error||'Unknown error');
      }
    } catch (e) {
      console.error('Trade save error:', e);
      toast('Failed to save trade: ' + e.message);
    }
  });

  console.log('New trade form rendering complete');
}

function renderTrades(){
  console.log('Rendering trades...');
  const container = document.getElementById('view-trades');
  if (!container) {
    console.error('Trades container not found!');
    return;
  }

  const template = document.getElementById('tpl-trades');
  if (!template) {
    console.error('Trades template not found!');
    return;
  }

  container.innerHTML = template.innerHTML;
  container.classList.remove('hidden');
  console.log('Trades template rendered');

  const tbody = container.querySelector('#trades-body');
  const symSel = container.querySelector('#flt-symbol');

  if (!tbody || !symSel) {
    console.error('Trades table or symbol select not found!');
    return;
  }

  // Populate symbol filter with available instruments
  let instruments = state.instruments || [];
  if (!instruments || instruments.length === 0) {
    instruments = Object.values(PREDEFINED_INSTRUMENTS);
  }

  symSel.innerHTML = '<option value="">All Symbols</option>' +
    instruments.map(i => `<option value="${i.symbol}">${i.displayName || i.symbol}</option>`).join('');

  async function load(){
    console.log('Loading trades...');
    const sym = symSel.value || '';
    const q = sym ? ('?symbol='+encodeURIComponent(sym)) : '';
    const res = await apiGet('/api/trades'+q);
    const trades = res.trades || [];
    console.log('Loaded trades:', trades.length);
    tbody.innerHTML = trades.map(t => trRow(t)).join('');
    attachRowActions();
  }
  function trRow(t){
    return `<tr>
      <td>${t.id}</td><td>${t.date||''}</td><td>${t.time||''}</td><td>${t.symbol||''}</td><td>${t.direction||''}</td>
      <td>${fmt(t.entry)}</td><td>${fmt(t.stop)}</td><td>${fmt(t.take_profit)}</td><td>${fmt(t.qty)}</td><td>${fmt(t.rr)}</td>
      <td>${t.status||''}</td><td>${fmt(t.pnl)}</td>
      <td>
        <button class="mark" data-id="${t.id}" data-action="TP">TP</button>
        <button class="mark" data-id="${t.id}" data-action="SL">SL</button>
        <button class="mark" data-id="${t.id}" data-action="BE">BE</button>
        <button class="mark-partial" data-id="${t.id}">Partial</button>
        <button class="mark" data-id="${t.id}" data-action="Cancelled">Cancel</button>
      </td>
    </tr>`;
  }
  function attachRowActions(){
    container.querySelectorAll('button.mark').forEach(btn => btn.addEventListener('click', async () => {
      const id = btn.dataset.id; const action = btn.dataset.action;
      const res = await apiPost(`/api/trades/${id}/mark`, { action });
      if (res.ok) { toast('Updated successfully'); load(); } else toast('Update failed');
    }));
    container.querySelectorAll('button.mark-partial').forEach(btn => btn.addEventListener('click', async () => {
      const id = btn.dataset.id;
      const percent = Number(prompt('Partial close percentage (0-100):', '50'));
      if (!isFinite(percent)) return;
      const res = await apiPost(`/api/trades/${id}/mark`, { action: 'Partial', percent });
      if (res.ok) { toast('Updated successfully'); load(); } else toast('Update failed');
    }));
  }

  container.querySelector('#apply-filter').addEventListener('click', async () => {
    const sd = document.getElementById('flt-start').value;
    const ed = document.getElementById('flt-end').value;
    const sym = document.getElementById('flt-symbol').value;
    const sel = Array.from(document.getElementById('flt-status').selectedOptions).map(o=>o.value).join(',');
    const q = new URLSearchParams({ start_date: sd||'', end_date: ed||'', status: sel||'', symbol: sym||'' }).toString();
    const res = await apiGet('/api/trades?'+q);
    const trades = res.trades || [];
    tbody.innerHTML = trades.map(t => trRow(t)).join('');
    attachRowActions();
  });

  load();
}

function renderSettings(){
  console.log('Rendering settings...');
  const container = document.getElementById('view-settings');
  if (!container) {
    console.error('Settings container not found!');
    return;
  }

  const template = document.getElementById('tpl-settings');
  if (!template) {
    console.error('Settings template not found!');
    return;
  }

  container.innerHTML = template.innerHTML;
  container.classList.remove('hidden');
  console.log('Settings template rendered');

  const form = container.querySelector('#settings-form');
  if (!form) {
    console.error('Settings form not found!');
    return;
  }

  const b = state.settings || {};
  console.log('Loading settings:', b);

  // Fill form fields
  form.starting_balance.value = b.starting_balance || 10000;
  form.daily_target.value = b.daily_target || 515;
  form.daily_max_loss.value = b.daily_max_loss || 1500;
  form.tp_pct.value = (b.tp_pct != null ? b.tp_pct : 0.30);
  form.sl_pct.value = (b.sl_pct != null ? b.sl_pct : 0.15);

  console.log('Form fields filled');

  const tbody = container.querySelector('#inst-body');
  if (!tbody) {
    console.error('Instruments table body not found!');
    return;
  }

  function drawInstruments(){
    const instruments = state.instruments || [];
    console.log('Drawing instruments:', instruments);
    tbody.innerHTML = instruments.map(i => instRow(i)).join('');
  }

  function instRow(i){
    return `<tr>
      <td><input value="${i.symbol||''}" class="inst-symbol" placeholder="e.g. GOLD"></td>
      <td><input type="number" step="0.0001" value="${i.tick_size||''}" class="inst-tick-size" placeholder="0.01"></td>
      <td><input type="number" step="0.01" value="${i.tick_value||''}" class="inst-tick-value" placeholder="0.01"></td>
      <td><input type="number" step="1" value="${i.contract_size||''}" class="inst-contract-size" placeholder="100"></td>
      <td><button type="button" onclick="this.closest('tr').remove()">Remove</button></td>
    </tr>`;
  }

  drawInstruments();

  const addBtn = container.querySelector('#add-inst');
  if (addBtn) {
    addBtn.addEventListener('click', () => {
      console.log('Adding new instrument');
      if (!state.instruments) state.instruments = [];
      state.instruments.push({ symbol: '', tick_size: '', tick_value: '', contract_size: 1 });
      drawInstruments();
    });
  }

  form.addEventListener('submit', async (ev) => {
    ev.preventDefault();
    console.log('Settings form submitted');

    try {
      const instruments = Array.from(tbody.querySelectorAll('tr')).map(tr => {
        const symbolInput = tr.querySelector('.inst-symbol');
        const tickSizeInput = tr.querySelector('.inst-tick-size'); 
        const tickValueInput = tr.querySelector('.inst-tick-value');
        const contractSizeInput = tr.querySelector('.inst-contract-size');

        if (!symbolInput || !tickSizeInput || !tickValueInput || !contractSizeInput) {
          console.error('Missing input elements in row:', tr);
          return null;
        }

        return {
          symbol: symbolInput.value.trim(),
          tick_size: numOrNull(tickSizeInput.value),
          tick_value: numOrNull(tickValueInput.value),
          contract_size: numOrNull(contractSizeInput.value) || 1,
        };
      }).filter(i => i && i.symbol);

      console.log('Collected instruments:', instruments);

      const payload = {
        starting_balance: numOrNull(form.starting_balance.value),
        daily_target: numOrNull(form.daily_target.value),
        daily_max_loss: numOrNull(form.daily_max_loss.value),
        tp_pct: Number(form.tp_pct.value),
        sl_pct: Number(form.sl_pct.value),
        instruments
      };

      console.log('Sending payload:', payload);

      const res = await apiPost('/api/settings', payload);
      console.log('API response:', res);

      if (res && res.ok) {
        toast('Settings saved successfully');
        console.log('Refreshing settings after save...');
        await refreshSettings();
        console.log('Settings refresh complete');
      } else {
        const errorMsg = (res && res.error) || 'Unknown error';
        console.error('Settings save failed:', errorMsg);
        toast('Failed to save settings: ' + errorMsg);
      }
    } catch (error) {
      console.error('Settings save error:', error);
      toast('Error saving settings: ' + error.message);
    }
  });

  console.log('Settings rendering complete');
}

async function apiGet(path){
  try {
    console.log('API GET request:', path);
    const url = `?path=${encodeURIComponent(path)}`;
    const res = await fetch(url, { method: 'GET', headers: { 'Content-Type': 'application/json' }});
    
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}: ${res.statusText}`);
    }
    
    const data = await res.json();
    console.log('API GET response:', data);
    return data;
  } catch (error) {
    console.error('API GET error:', error);
    return { ok: false, error: error.message };
  }
}
async function apiPost(path, body){
  try {
    console.log('API POST request:', path, body);
    const url = `?path=${encodeURIComponent(path)}`;
    const res = await fetch(url, { 
      method: 'POST', 
      headers: { 'Content-Type': 'application/json' }, 
      body: JSON.stringify(body||{}) 
    });
    
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}: ${res.statusText}`);
    }
    
    const data = await res.json();
    console.log('API POST response:', data);
    return data;
  } catch (error) {
    console.error('API POST error:', error);
    return { ok: false, error: error.message };
  }
}

function computePlanClient({ balance, tp_pct, sl_pct, entry, stop, direction, instrument }){
  const risk_amount = round2(balance * sl_pct);
  const planned_tp_amount = round2(balance * tp_pct);
  const planned_sl_amount = round2(balance * sl_pct);
  const rr = planned_sl_amount===0?0:round2(planned_tp_amount/planned_sl_amount);
  let qty = '';
  if (isFinite(entry) && isFinite(stop) && instrument && isFinite(instrument.tick_size) && isFinite(instrument.tick_value)){
    const ticks = Math.abs(entry - stop)/instrument.tick_size;
    const riskPer = ticks * instrument.tick_value;
    if (riskPer>0) qty = Math.max(1, Math.floor(risk_amount/riskPer));
  }
  let take_profit = '';
  if (isFinite(entry) && isFinite(stop)){
    const d = Math.abs(entry - stop);
    take_profit = direction==='Long' ? roundTo(entry + d, instrument && instrument.tick_size) : roundTo(entry - d, instrument && instrument.tick_size);
  }
  return { risk_amount, planned_tp_amount, planned_sl_amount, rr, qty, take_profit };
}
function round2(n){ return Math.round(Number(n||0)*100)/100; }
function roundTo(n, step){ if(!step) return round2(n); const k=Math.round(n/step)*step; return round2(k); }
function numOrNull(v){ const n=Number(v); return isNaN(n)? null : n; }

function toast(msg){
  try {
    console.log('Toast message:', msg);
    const el = document.getElementById('toast');
    if (!el) {
      console.error('Toast element not found!');
      alert(msg); // Fallback
      return;
    }
    el.textContent = msg;
    el.classList.remove('hidden');
    setTimeout(() => {
      if (el) el.classList.add('hidden');
    }, 3000);
  } catch (error) {
    console.error('Toast error:', error);
    alert(msg); // Fallback
  }
}
